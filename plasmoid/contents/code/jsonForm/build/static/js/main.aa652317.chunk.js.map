{"version":3,"sources":["qwebchannel.js","index.js"],"names":["QWebChannelMessageTypes","QObject","name","data","webChannel","this","__id__","objects","__objectSignals__","__propertyCache__","object","addSignal","signalData","isPropertyNotifySignal","signalName","signalIndex","connect","callback","push","exec","type","signal","console","error","disconnect","idx","indexOf","splice","length","invokeSignalCallbacks","signalArgs","connections","forEach","apply","unwrapQObject","response","Array","ret","i","undefined","id","objectId","qObject","destroyed","propertyNames","propertyName","unwrapProperties","propertyIdx","propertyUpdate","signals","propertyMap","propertyIndex","propertyValue","signalEmitted","methods","methodData","methodName","methodIdx","args","arguments","result","properties","propertyInfo","notifySignalData","Object","defineProperty","configurable","get","warn","set","value","enums","module","exports","QWebChannel","transport","initCallback","send","channel","JSON","stringify","onmessage","message","parse","handleSignal","handleResponse","handlePropertyUpdate","execCallbacks","execId","Number","MAX_VALUE","MIN_VALUE","hasOwnProperty","debug","objectName","editor","backend","window","onload","log","Qt","qt","webChannelTransport","document","getElementById","addEventListener","setFormData","getValue","formDataChanged","schema","destroy","edit","iconlib","theme","disable_collapse","startval","getTreeCurrentData","schemaForm","formData","styleChanged","style","innerHTML"],"mappings":"sGAqDA,IAAIA,EACQ,EADRA,EAEgB,EAFhBA,EAGM,EAHNA,EAIM,EAJNA,EAKO,EALPA,EAMc,EANdA,EAOiB,EAPjBA,EAQsB,EARtBA,EASa,EATbA,EAUU,GA0Hd,SAASC,EAAQC,EAAMC,EAAMC,GAEzBC,KAAKC,OAASJ,EACdE,EAAWG,QAAQL,GAAQG,KAG3BA,KAAKG,kBAAoB,GAGzBH,KAAKI,kBAAoB,GAEzB,IAAIC,EAASL,KA0Db,SAASM,EAAUC,EAAYC,GAE3B,IAAIC,EAAaF,EAAW,GACxBG,EAAcH,EAAW,GAC7BF,EAAOI,GAAc,CACjBE,QAAS,SAASC,GACW,oBAAdA,GAKXP,EAAOF,kBAAkBO,GAAeL,EAAOF,kBAAkBO,IAAgB,GACjFL,EAAOF,kBAAkBO,GAAaG,KAAKD,GAEtCJ,GAAyC,cAAfC,GAG3BV,EAAWe,KAAK,CACZC,KAAMpB,EACNU,OAAQA,EAAOJ,OACfe,OAAQN,KAbZO,QAAQC,MAAM,2CAA6CT,IAiBnEU,WAAY,SAASP,GACjB,GAAyB,oBAAdA,EAAX,CAIAP,EAAOF,kBAAkBO,GAAeL,EAAOF,kBAAkBO,IAAgB,GACjF,IAAIU,EAAMf,EAAOF,kBAAkBO,GAAaW,QAAQT,IAC3C,IAATQ,GAIJf,EAAOF,kBAAkBO,GAAaY,OAAOF,EAAK,GAC7CZ,GAA2E,IAAjDH,EAAOF,kBAAkBO,GAAaa,QAEjExB,EAAWe,KAAK,CACZC,KAAMpB,EACNU,OAAQA,EAAOJ,OACfe,OAAQN,KATZO,QAAQC,MAAM,oCAAsCT,EAAa,OAASG,EAASf,WANnFoB,QAAQC,MAAM,gDAAkDT,KAyBhF,SAASe,EAAsBf,EAAYgB,GAEvC,IAAIC,EAAcrB,EAAOF,kBAAkBM,GACvCiB,GACAA,EAAYC,SAAQ,SAASf,GACzBA,EAASgB,MAAMhB,EAAUa,MA6GrC,IAAK,IAAI5B,KA3NTG,KAAK6B,cAAgB,SAASC,GAE1B,GAAIA,aAAoBC,MAAO,CAG3B,IADA,IAAIC,EAAM,IAAID,MAAMD,EAASP,QACpBU,EAAI,EAAGA,EAAIH,EAASP,SAAUU,EACnCD,EAAIC,GAAK5B,EAAOwB,cAAcC,EAASG,IAE3C,OAAOD,EAEX,IAAKF,IACGA,EAAS,sBACMI,IAAhBJ,EAASK,GACZ,OAAOL,EAGX,IAAIM,EAAWN,EAASK,GACxB,GAAIpC,EAAWG,QAAQkC,GACnB,OAAOrC,EAAWG,QAAQkC,GAE9B,GAAKN,EAAShC,KAAd,CAKA,IAAIuC,EAAU,IAAIzC,EAASwC,EAAUN,EAAShC,KAAMC,GAmBpD,OAlBAsC,EAAQC,UAAU3B,SAAQ,WACtB,GAAIZ,EAAWG,QAAQkC,KAAcC,EAAS,QACnCtC,EAAWG,QAAQkC,GAK1B,IAAIG,EAAgB,GACpB,IAAK,IAAIC,KAAgBH,EACrBE,EAAc1B,KAAK2B,GAEvB,IAAK,IAAIpB,KAAOmB,SACLF,EAAQE,EAAcnB,QAKzCiB,EAAQI,mBACDJ,EAvBHpB,QAAQC,MAAM,iCAAmCkB,EAAW,mBA0BpEpC,KAAKyC,iBAAmB,WAEpB,IAAK,IAAIC,KAAerC,EAAOD,kBAC3BC,EAAOD,kBAAkBsC,GAAerC,EAAOwB,cAAcxB,EAAOD,kBAAkBsC,KAiE9F1C,KAAK2C,eAAiB,SAASC,EAASC,GAGpC,IAAK,IAAIC,KAAiBD,EAAa,CACnC,IAAIE,EAAgBF,EAAYC,GAChCzC,EAAOD,kBAAkB0C,GAAiBC,EAG9C,IAAK,IAAItC,KAAcmC,EAGnBpB,EAAsBf,EAAYmC,EAAQnC,KAIlDT,KAAKgD,cAAgB,SAASvC,EAAYgB,GAEtCD,EAAsBf,EAAYgB,IAiFtC3B,EAAKmD,QAAQtB,SA9Eb,SAAmBuB,GAEf,IAAIC,EAAaD,EAAW,GACxBE,EAAYF,EAAW,GAC3B7C,EAAO8C,GAAc,WAGjB,IAFA,IACIvC,EADAyC,EAAO,GAEFpB,EAAI,EAAGA,EAAIqB,UAAU/B,SAAUU,EACR,oBAAjBqB,UAAUrB,GACjBrB,EAAW0C,UAAUrB,GAErBoB,EAAKxC,KAAKyC,UAAUrB,IAG5BlC,EAAWe,KAAK,CACZ,KAAQnB,EACR,OAAUU,EAAOJ,OACjB,OAAUmD,EACV,KAAQC,IACT,SAASvB,GACR,QAAiBI,IAAbJ,EAAwB,CACxB,IAAIyB,EAASlD,EAAOwB,cAAcC,GAC9BlB,GACCA,EAAU2C,WAyD/BzD,EAAK0D,WAAW7B,SAlDhB,SAA0B8B,GAEtB,IAAIX,EAAgBW,EAAa,GAC7BjB,EAAeiB,EAAa,GAC5BC,EAAmBD,EAAa,GAIpCpD,EAAOD,kBAAkB0C,GAAiBW,EAAa,GAEnDC,IAC4B,IAAxBA,EAAiB,KAEjBA,EAAiB,GAAKlB,EAAe,WAEzClC,EAAUoD,GAAkB,IAGhCC,OAAOC,eAAevD,EAAQmC,EAAc,CACxCqB,cAAc,EACdC,IAAK,WACD,IAAIf,EAAgB1C,EAAOD,kBAAkB0C,GAM7C,YALsBZ,IAAlBa,GAEA9B,QAAQ8C,KAAK,mDAAsDvB,EAAe,eAAkBnC,EAAOJ,QAGxG8C,GAEXiB,IAAK,SAASC,QACI/B,IAAV+B,GAIJ5D,EAAOD,kBAAkB0C,GAAiBmB,EAC1ClE,EAAWe,KAAK,CACZ,KAAQnB,EACR,OAAUU,EAAOJ,OACjB,SAAY6C,EACZ,MAASmB,KARThD,QAAQ8C,KAAK,uBAAyBvB,EAAe,uCAqBrE1C,EAAK8C,QAAQjB,SAAQ,SAASX,GAAUV,EAAUU,GAAQ,MAEzClB,EAAKoE,MAClB7D,EAAOR,GAAQC,EAAKoE,MAAMrE,GAM9BsE,EAAOC,QAAU,CACbC,YAzWU,SAASC,EAAWC,GAElC,GAAyB,kBAAdD,GAAoD,oBAAnBA,EAAUE,KAAtD,CAMA,IAAIC,EAAUzE,KACdA,KAAKsE,UAAYA,EAEjBtE,KAAKwE,KAAO,SAAS1E,GAEI,kBAAVA,IACPA,EAAO4E,KAAKC,UAAU7E,IAE1B2E,EAAQH,UAAUE,KAAK1E,IAG3BE,KAAKsE,UAAUM,UAAY,SAASC,GAEhC,IAAI/E,EAAO+E,EAAQ/E,KAInB,OAHoB,kBAATA,IACPA,EAAO4E,KAAKI,MAAMhF,IAEdA,EAAKiB,MACT,KAAKpB,EACD8E,EAAQM,aAAajF,GACrB,MACJ,KAAKH,EACD8E,EAAQO,eAAelF,GACvB,MACJ,KAAKH,EACD8E,EAAQQ,qBAAqBnF,GAC7B,MACJ,QACImB,QAAQC,MAAM,4BAA6B2D,EAAQ/E,QAK/DE,KAAKkF,cAAgB,GACrBlF,KAAKmF,OAAS,EACdnF,KAAKc,KAAO,SAAShB,EAAMc,GAElBA,GAKD6D,EAAQU,SAAWC,OAAOC,YAE1BZ,EAAQU,OAASC,OAAOE,WAExBxF,EAAKyF,eAAe,MACpBtE,QAAQC,MAAM,yCAA2CwD,KAAKC,UAAU7E,KAG5EA,EAAKqC,GAAKsC,EAAQU,SAClBV,EAAQS,cAAcpF,EAAKqC,IAAMvB,EACjC6D,EAAQD,KAAK1E,KAbT2E,EAAQD,KAAK1E,IAgBrBE,KAAKE,QAAU,GAEfF,KAAK+E,aAAe,SAASF,GAEzB,IAAIxE,EAASoE,EAAQvE,QAAQ2E,EAAQxE,QACjCA,EACAA,EAAO2C,cAAc6B,EAAQ7D,OAAQ6D,EAAQxB,MAE7CpC,QAAQ8C,KAAK,qBAAuBc,EAAQxE,OAAS,KAAOwE,EAAQ7D,SAI5EhB,KAAKgF,eAAiB,SAASH,GAEtBA,EAAQU,eAAe,OAI5Bd,EAAQS,cAAcL,EAAQ1C,IAAI0C,EAAQ/E,aACnC2E,EAAQS,cAAcL,EAAQ1C,KAJjClB,QAAQC,MAAM,sCAAuCwD,KAAKC,UAAUE,KAO5E7E,KAAKiF,qBAAuB,SAASJ,GAEjC,IAAK,IAAI5C,KAAK4C,EAAQ/E,KAAM,CACxB,IAAIA,EAAO+E,EAAQ/E,KAAKmC,GACpB5B,EAASoE,EAAQvE,QAAQJ,EAAKO,QAC9BA,EACAA,EAAOsC,eAAe7C,EAAK8C,QAAS9C,EAAK0D,YAEzCvC,QAAQ8C,KAAK,8BAAgCjE,EAAKO,OAAS,KAAOP,EAAKkB,QAG/EyD,EAAQ3D,KAAK,CAACC,KAAMpB,KAGxBK,KAAKwF,MAAQ,SAASX,GAElBJ,EAAQD,KAAK,CAACzD,KAAMpB,EAA+BG,KAAM+E,KAG7DJ,EAAQ3D,KAAK,CAACC,KAAMpB,IAA+B,SAASG,GACxD,IAAK,IAAI2F,KAAc3F,EACN,IAAIF,EAAQ6F,EAAY3F,EAAK2F,GAAahB,GAG3D,IAAK,IAAIgB,KAAchB,EAAQvE,QAC3BuE,EAAQvE,QAAQuF,GAAYhD,mBAE5B8B,GACAA,EAAaE,GAEjBA,EAAQ3D,KAAK,CAACC,KAAMpB,YAhHpBsB,QAAQC,MAAM,gIACwBoD,EAAa,4BAA8BA,EAAUE,S,6BCtEnG,WASIkB,EAEAC,EAXJ,wBAeEC,OAAOC,OAAS,WACd5E,QAAQ6E,IAAI,SACZ,IAAIC,cAAeC,GAAGC,qBAAqB,SAASxB,GAIhDmB,OAAOM,SAASC,eAAe,oBAAoBC,iBAAiB,SAAQ,kBAAMT,EAAQU,YAAYX,EAAOY,gBAC7GX,EAAUlB,EAAQvE,QAAQyF,SAClBY,gBAAgB5F,SAAQ,SAAC6F,EAAO1G,GACnC4F,GACDA,EAAOe,UAGTf,EAAS,IAAKgB,aAAgBd,OAAOM,SAASC,eAAe,QAAQ,CAACQ,QAAS,eAAeH,OAAOA,EAAOI,MAAM,UAAUC,kBAAiB,EAAMC,SAAShH,OAE9J6F,EAAQoB,oBAAmB,SAACxD,GAC5BmC,EAAS,IAAKgB,aAAgBd,OAAOM,SAASC,eAAe,QAAQ,CAACQ,QAAS,eAAeH,OAAOjD,EAAOyD,WAAWF,SAASvD,EAAO0D,SAASL,MAAM,UAAUC,kBAAiB,OAEjLlB,EAAQuB,aAAavG,SAAQ,SAACwG,GAAD,OAAWvB,OAAOM,SAASC,eAAe,SAASiB,UAAYD,KAC5FxB,EAAQwB,OAAM,SAAAA,GAAK,OAAIvB,OAAOM,SAASC,eAAe,SAASiB,UAAYD,W","file":"static/js/main.aa652317.chunk.js","sourcesContent":["/****************************************************************************\n **\n ** Copyright (C) 2016 The Qt Company Ltd.\n ** Copyright (C) 2014 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Milian Wolff <milian.wolff@kdab.com>\n ** Contact: https://www.qt.io/licensing/\n **\n ** This file is part of the QtWebChannel module of the Qt Toolkit.\n **\n ** $QT_BEGIN_LICENSE:BSD$\n ** Commercial License Usage\n ** Licensees holding valid commercial Qt licenses may use this file in\n ** accordance with the commercial license agreement provided with the\n ** Software or, alternatively, in accordance with the terms contained in\n ** a written agreement between you and The Qt Company. For licensing terms\n ** and conditions see https://www.qt.io/terms-conditions. For further\n ** information use the contact form at https://www.qt.io/contact-us.\n **\n ** BSD License Usage\n ** Alternatively, you may use this file under the terms of the BSD license\n ** as follows:\n **\n ** \"Redistribution and use in source and binary forms, with or without\n ** modification, are permitted provided that the following conditions are\n ** met:\n **   * Redistributions of source code must retain the above copyright\n **     notice, this list of conditions and the following disclaimer.\n **   * Redistributions in binary form must reproduce the above copyright\n **     notice, this list of conditions and the following disclaimer in\n **     the documentation and/or other materials provided with the\n **     distribution.\n **   * Neither the name of The Qt Company Ltd nor the names of its\n **     contributors may be used to endorse or promote products derived\n **     from this software without specific prior written permission.\n **\n **\n ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n ** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n **\n ** $QT_END_LICENSE$\n **\n ****************************************************************************/\n\n\"use strict\";\n\nvar QWebChannelMessageTypes = {\n    signal: 1,\n    propertyUpdate: 2,\n    init: 3,\n    idle: 4,\n    debug: 5,\n    invokeMethod: 6,\n    connectToSignal: 7,\n    disconnectFromSignal: 8,\n    setProperty: 9,\n    response: 10,\n};\n\nvar QWebChannel = function(transport, initCallback)\n{\n    if (typeof transport !== \"object\" || typeof transport.send !== \"function\") {\n        console.error(\"The QWebChannel expects a transport object with a send function and onmessage callback property.\" +\n            \" Given is: transport: \" + typeof(transport) + \", transport.send: \" + typeof(transport.send));\n        return;\n    }\n\n    var channel = this;\n    this.transport = transport;\n\n    this.send = function(data)\n    {\n        if (typeof(data) !== \"string\") {\n            data = JSON.stringify(data);\n        }\n        channel.transport.send(data);\n    }\n\n    this.transport.onmessage = function(message)\n    {\n        var data = message.data;\n        if (typeof data === \"string\") {\n            data = JSON.parse(data);\n        }\n        switch (data.type) {\n            case QWebChannelMessageTypes.signal:\n                channel.handleSignal(data);\n                break;\n            case QWebChannelMessageTypes.response:\n                channel.handleResponse(data);\n                break;\n            case QWebChannelMessageTypes.propertyUpdate:\n                channel.handlePropertyUpdate(data);\n                break;\n            default:\n                console.error(\"invalid message received:\", message.data);\n                break;\n        }\n    }\n\n    this.execCallbacks = {};\n    this.execId = 0;\n    this.exec = function(data, callback)\n    {\n        if (!callback) {\n            // if no callback is given, send directly\n            channel.send(data);\n            return;\n        }\n        if (channel.execId === Number.MAX_VALUE) {\n            // wrap\n            channel.execId = Number.MIN_VALUE;\n        }\n        if (data.hasOwnProperty(\"id\")) {\n            console.error(\"Cannot exec message with property id: \" + JSON.stringify(data));\n            return;\n        }\n        data.id = channel.execId++;\n        channel.execCallbacks[data.id] = callback;\n        channel.send(data);\n    };\n\n    this.objects = {};\n\n    this.handleSignal = function(message)\n    {\n        var object = channel.objects[message.object];\n        if (object) {\n            object.signalEmitted(message.signal, message.args);\n        } else {\n            console.warn(\"Unhandled signal: \" + message.object + \"::\" + message.signal);\n        }\n    }\n\n    this.handleResponse = function(message)\n    {\n        if (!message.hasOwnProperty(\"id\")) {\n            console.error(\"Invalid response message received: \", JSON.stringify(message));\n            return;\n        }\n        channel.execCallbacks[message.id](message.data);\n        delete channel.execCallbacks[message.id];\n    }\n\n    this.handlePropertyUpdate = function(message)\n    {\n        for (var i in message.data) {\n            var data = message.data[i];\n            var object = channel.objects[data.object];\n            if (object) {\n                object.propertyUpdate(data.signals, data.properties);\n            } else {\n                console.warn(\"Unhandled property update: \" + data.object + \"::\" + data.signal);\n            }\n        }\n        channel.exec({type: QWebChannelMessageTypes.idle});\n    }\n\n    this.debug = function(message)\n    {\n        channel.send({type: QWebChannelMessageTypes.debug, data: message});\n    };\n\n    channel.exec({type: QWebChannelMessageTypes.init}, function(data) {\n        for (var objectName in data) {\n            var object = new QObject(objectName, data[objectName], channel);\n        }\n        // now unwrap properties, which might reference other registered objects\n        for (var objectName in channel.objects) {\n            channel.objects[objectName].unwrapProperties();\n        }\n        if (initCallback) {\n            initCallback(channel);\n        }\n        channel.exec({type: QWebChannelMessageTypes.idle});\n    });\n};\n\nfunction QObject(name, data, webChannel)\n{\n    this.__id__ = name;\n    webChannel.objects[name] = this;\n\n    // List of callbacks that get invoked upon signal emission\n    this.__objectSignals__ = {};\n\n    // Cache of all properties, updated when a notify signal is emitted\n    this.__propertyCache__ = {};\n\n    var object = this;\n\n    // ----------------------------------------------------------------------\n\n    this.unwrapQObject = function(response)\n    {\n        if (response instanceof Array) {\n            // support list of objects\n            var ret = new Array(response.length);\n            for (var i = 0; i < response.length; ++i) {\n                ret[i] = object.unwrapQObject(response[i]);\n            }\n            return ret;\n        }\n        if (!response\n            || !response[\"__QObject*__\"]\n            || response.id === undefined) {\n            return response;\n        }\n\n        var objectId = response.id;\n        if (webChannel.objects[objectId])\n            return webChannel.objects[objectId];\n\n        if (!response.data) {\n            console.error(\"Cannot unwrap unknown QObject \" + objectId + \" without data.\");\n            return;\n        }\n\n        var qObject = new QObject( objectId, response.data, webChannel );\n        qObject.destroyed.connect(function() {\n            if (webChannel.objects[objectId] === qObject) {\n                delete webChannel.objects[objectId];\n                // reset the now deleted QObject to an empty {} object\n                // just assigning {} though would not have the desired effect, but the\n                // below also ensures all external references will see the empty map\n                // NOTE: this detour is necessary to workaround QTBUG-40021\n                var propertyNames = [];\n                for (var propertyName in qObject) {\n                    propertyNames.push(propertyName);\n                }\n                for (var idx in propertyNames) {\n                    delete qObject[propertyNames[idx]];\n                }\n            }\n        });\n        // here we are already initialized, and thus must directly unwrap the properties\n        qObject.unwrapProperties();\n        return qObject;\n    }\n\n    this.unwrapProperties = function()\n    {\n        for (var propertyIdx in object.__propertyCache__) {\n            object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);\n        }\n    }\n\n    function addSignal(signalData, isPropertyNotifySignal)\n    {\n        var signalName = signalData[0];\n        var signalIndex = signalData[1];\n        object[signalName] = {\n            connect: function(callback) {\n                if (typeof(callback) !== \"function\") {\n                    console.error(\"Bad callback given to connect to signal \" + signalName);\n                    return;\n                }\n\n                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];\n                object.__objectSignals__[signalIndex].push(callback);\n\n                if (!isPropertyNotifySignal && signalName !== \"destroyed\") {\n                    // only required for \"pure\" signals, handled separately for properties in propertyUpdate\n                    // also note that we always get notified about the destroyed signal\n                    webChannel.exec({\n                        type: QWebChannelMessageTypes.connectToSignal,\n                        object: object.__id__,\n                        signal: signalIndex\n                    });\n                }\n            },\n            disconnect: function(callback) {\n                if (typeof(callback) !== \"function\") {\n                    console.error(\"Bad callback given to disconnect from signal \" + signalName);\n                    return;\n                }\n                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];\n                var idx = object.__objectSignals__[signalIndex].indexOf(callback);\n                if (idx === -1) {\n                    console.error(\"Cannot find connection of signal \" + signalName + \" to \" + callback.name);\n                    return;\n                }\n                object.__objectSignals__[signalIndex].splice(idx, 1);\n                if (!isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0) {\n                    // only required for \"pure\" signals, handled separately for properties in propertyUpdate\n                    webChannel.exec({\n                        type: QWebChannelMessageTypes.disconnectFromSignal,\n                        object: object.__id__,\n                        signal: signalIndex\n                    });\n                }\n            }\n        };\n    }\n\n    /**\n     * Invokes all callbacks for the given signalname. Also works for property notify callbacks.\n     */\n    function invokeSignalCallbacks(signalName, signalArgs)\n    {\n        var connections = object.__objectSignals__[signalName];\n        if (connections) {\n            connections.forEach(function(callback) {\n                callback.apply(callback, signalArgs);\n            });\n        }\n    }\n\n    this.propertyUpdate = function(signals, propertyMap)\n    {\n        // update property cache\n        for (var propertyIndex in propertyMap) {\n            var propertyValue = propertyMap[propertyIndex];\n            object.__propertyCache__[propertyIndex] = propertyValue;\n        }\n\n        for (var signalName in signals) {\n            // Invoke all callbacks, as signalEmitted() does not. This ensures the\n            // property cache is updated before the callbacks are invoked.\n            invokeSignalCallbacks(signalName, signals[signalName]);\n        }\n    }\n\n    this.signalEmitted = function(signalName, signalArgs)\n    {\n        invokeSignalCallbacks(signalName, signalArgs);\n    }\n\n    function addMethod(methodData)\n    {\n        var methodName = methodData[0];\n        var methodIdx = methodData[1];\n        object[methodName] = function() {\n            var args = [];\n            var callback;\n            for (var i = 0; i < arguments.length; ++i) {\n                if (typeof arguments[i] === \"function\")\n                    callback = arguments[i];\n                else\n                    args.push(arguments[i]);\n            }\n\n            webChannel.exec({\n                \"type\": QWebChannelMessageTypes.invokeMethod,\n                \"object\": object.__id__,\n                \"method\": methodIdx,\n                \"args\": args\n            }, function(response) {\n                if (response !== undefined) {\n                    var result = object.unwrapQObject(response);\n                    if (callback) {\n                        (callback)(result);\n                    }\n                }\n            });\n        };\n    }\n\n    function bindGetterSetter(propertyInfo)\n    {\n        var propertyIndex = propertyInfo[0];\n        var propertyName = propertyInfo[1];\n        var notifySignalData = propertyInfo[2];\n        // initialize property cache with current value\n        // NOTE: if this is an object, it is not directly unwrapped as it might\n        // reference other QObject that we do not know yet\n        object.__propertyCache__[propertyIndex] = propertyInfo[3];\n\n        if (notifySignalData) {\n            if (notifySignalData[0] === 1) {\n                // signal name is optimized away, reconstruct the actual name\n                notifySignalData[0] = propertyName + \"Changed\";\n            }\n            addSignal(notifySignalData, true);\n        }\n\n        Object.defineProperty(object, propertyName, {\n            configurable: true,\n            get: function () {\n                var propertyValue = object.__propertyCache__[propertyIndex];\n                if (propertyValue === undefined) {\n                    // This shouldn't happen\n                    console.warn(\"Undefined value in property cache for property \\\"\" + propertyName + \"\\\" in object \" + object.__id__);\n                }\n\n                return propertyValue;\n            },\n            set: function(value) {\n                if (value === undefined) {\n                    console.warn(\"Property setter for \" + propertyName + \" called with undefined value!\");\n                    return;\n                }\n                object.__propertyCache__[propertyIndex] = value;\n                webChannel.exec({\n                    \"type\": QWebChannelMessageTypes.setProperty,\n                    \"object\": object.__id__,\n                    \"property\": propertyIndex,\n                    \"value\": value\n                });\n            }\n        });\n\n    }\n\n    // ----------------------------------------------------------------------\n\n    data.methods.forEach(addMethod);\n\n    data.properties.forEach(bindGetterSetter);\n\n    data.signals.forEach(function(signal) { addSignal(signal, false); });\n\n    for (var name in data.enums) {\n        object[name] = data.enums[name];\n    }\n}\n\n//required for use with nodejs\nif (typeof module === 'object') {\n    module.exports = {\n        QWebChannel: QWebChannel\n    };\n}","import * as edit from \"@json-editor/json-editor\"\nimport *  as Qt from \"./qwebchannel\"\nimport \"spectre.css\"\nimport \"@fortawesome/fontawesome-free/js/all\"\n\n\n//var json = require(\"@json-editor/json-editor\");\n\nvar s;\nvar editor;\n\nvar backend;\n  \n\n\n  window.onload = function() {\n    console.log(\"sdasd\");\n    new Qt.QWebChannel(qt.webChannelTransport, function(channel) {\n        // all published objects are available in channel.objects under\n        // the identifier set in their attached WebChannel.id property\n        //channel.objects.backend.someFunction = setSchemaForm;\n        window.document.getElementById(\"submit-button-my\").addEventListener(\"click\",() => backend.setFormData(editor.getValue()));\n        backend = channel.objects.backend;\n        backend.formDataChanged.connect((schema,data) => {\n          if(editor){\n            editor.destroy();\n            \n          }\n          editor = new  edit.JSONEditor(window.document.getElementById(\"root\"),{iconlib: \"fontawesome5\",schema:schema,theme:\"spectre\",disable_collapse:false,startval:data});\n        });\n        backend.getTreeCurrentData((result) =>{ \n        editor = new  edit.JSONEditor(window.document.getElementById(\"root\"),{iconlib: \"fontawesome5\",schema:result.schemaForm,startval:result.formData,theme:\"spectre\",disable_collapse:false});\n        });\n        backend.styleChanged.connect((style) => window.document.getElementById(\"style\").innerHTML = style);\n        backend.style(style => window.document.getElementById(\"style\").innerHTML = style);\n        \n    });}\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals()\n"],"sourceRoot":""}